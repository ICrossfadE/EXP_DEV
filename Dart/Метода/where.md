`where` використовується для фільтрації колекцій. Він проходить по кожному елементу ітерації (наприклад, списку чи набору) і повертає нову ітерацію (`Iterable`), яка містить лише ті елементи, що задовольняють умову (передану як функція-предикат).

```dart
Iterable.where(bool test(T element));
```
- `test` — це функція, яка приймає елемент і повертає `true`, якщо цей елемент має бути включений в результат, або `false`, якщо його потрібно відфільтрувати.
### Як це працює:

- `where` не змінює оригінальну колекцію, а повертає нову ітерацію з відфільтрованими елементами.
- Оскільки результатом є `Iterable`, його можна перетворити на список або іншу колекцію, якщо це потрібно, використовуючи метод `toList()`.

```dart
List<int> numbers = [1, 2, 3, 4, 5, 6];

// Фільтруємо лише парні числа
Iterable<int> evenNumbers = numbers.where((number) => number.isEven);

print(evenNumbers); // Виведе: (2, 4, 6)
```

### Як це працює:

- У цьому прикладі функція `(number) => number.isEven` перевіряє кожен елемент списку.
- Якщо число парне (тобто умова `number.isEven` повертає `true`), воно буде включено в результат.
- Якщо число непарне, воно відфільтровується (викидається з результату).

### Приклад з рядками:

```dart
List<String> names = ['Alice', 'Bob', 'Charlie', 'David'];

// Фільтруємо імена, які починаються з 'A'
Iterable<String> namesWithA = names.where((name) => name.startsWith('A'));

print(namesWithA); // Виведе: (Alice)

```

### Комбінування з іншими методами:

```dart
List<int> numbers = [1, 2, 3, 4, 5, 6];

// Фільтруємо парні числа і множимо їх на 2
List<int> processedNumbers = numbers
  .where((number) => number.isEven)
  .map((number) => number * 2)
  .toList();

print(processedNumbers); // Виведе: [4, 8, 12]
```

### Висновок:

Метод `where` дозволяє легко фільтрувати колекції в Dart, залишаючи тільки ті елементи, які задовольняють певну умову. Він повертає `Iterable`, що дозволяє зберігати обчислення до моменту, коли вони дійсно потрібні, і може бути комбінований з іншими методами для обробки даних.